#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// Definição da estrutura do Território
typedef struct {
    char nome[30];
    char cor[10];
    int tropas;
} Territorio;

// Protótipos das funções
Territorio* alocarTerritorios(int quantidade);
void cadastrarTerritorios(Territorio* mapa, int quantidade);
void exibirTerritorios(Territorio* mapa, int quantidade);
void atacar(Territorio* atacante, Territorio* defensor);
void liberarMemoria(Territorio* mapa);
int validarAtaque(Territorio* atacante, Territorio* defensor);

int main() {
    srand(time(NULL)); // Inicializa o gerador de números aleatórios
    
    int quantidade;
    printf("=== WAR ESTRUTURADO - SIMULADOR DE BATALHAS ===\n\n");
    printf("Quantos territorios deseja cadastrar? ");
    scanf("%d", &quantidade);
    
    // Aloca memória para os territórios
    Territorio* mapa = alocarTerritorios(quantidade);
    if (mapa == NULL) {
        printf("Erro ao alocar memoria!\n");
        return 1;
    }
    
    // Cadastra os territórios
    cadastrarTerritorios(mapa, quantidade);
    
    int opcao;
    do {
        printf("\n=== MENU PRINCIPAL ===\n");
        printf("1. Exibir territorios\n");
        printf("2. Realizar ataque\n");
        printf("0. Sair\n");
        printf("Escolha uma opcao: ");
        scanf("%d", &opcao);
        
        switch(opcao) {
            case 1:
                exibirTerritorios(mapa, quantidade);
                break;
            case 2:
                {
                    int indiceAtacante, indiceDefensor;
                    exibirTerritorios(mapa, quantidade);
                    
                    printf("\nSelecione o territorio ATACANTE (indice): ");
                    scanf("%d", &indiceAtacante);
                    
                    printf("Selecione o territorio DEFENSOR (indice): ");
                    scanf("%d", &indiceDefensor);
                    
                    // Valida os índices
                    if (indiceAtacante < 0 || indiceAtacante >= quantidade || 
                        indiceDefensor < 0 || indiceDefensor >= quantidade) {
                        printf("Indices invalidos!\n");
                        break;
                    }
                    
                    // Valida o ataque
                    if (!validarAtaque(&mapa[indiceAtacante], &mapa[indiceDefensor])) {
                        printf("Ataque invalido! Verifique as regras.\n");
                        break;
                    }
                    
                    // Realiza o ataque
                    atacar(&mapa[indiceAtacante], &mapa[indiceDefensor]);
                }
                break;
            case 0:
                printf("Encerrando o programa...\n");
                break;
            default:
                printf("Opcao invalida!\n");
        }
    } while (opcao != 0);
    
    // Libera a memória alocada
    liberarMemoria(mapa);
    
    return 0;
}

// Função para alocar memória para os territórios
Territorio* alocarTerritorios(int quantidade) {
    return (Territorio*)calloc(quantidade, sizeof(Territorio));
}

// Função para cadastrar os territórios
void cadastrarTerritorios(Territorio* mapa, int quantidade) {
    printf("\n=== CADASTRO DE TERRITORIOS ===\n");
    for (int i = 0; i < quantidade; i++) {
        printf("\nTerritorio %d:\n", i+1);
        printf("Nome: ");
        scanf("%s", mapa[i].nome);
        printf("Cor do exercito: ");
        scanf("%s", mapa[i].cor);
        printf("Quantidade de tropas: ");
        scanf("%d", &mapa[i].tropas);
    }
}

// Função para exibir os territórios
void exibirTerritorios(Territorio* mapa, int quantidade) {
    printf("\n=== TERRITORIOS CADASTRADOS ===\n");
    printf("Indice | Nome           | Cor      | Tropas\n");
    printf("-------------------------------------------\n");
    for (int i = 0; i < quantidade; i++) {
        printf("%6d | %-14s | %-8s | %6d\n", 
               i, mapa[i].nome, mapa[i].cor, mapa[i].tropas);
    }
}

// Função para validar se um ataque é permitido
int validarAtaque(Territorio* atacante, Territorio* defensor) {
    // Verifica se as cores são diferentes
    if (strcmp(atacante->cor, defensor->cor) == 0) {
        return 0;
    }
    
    // Verifica se o atacante tem tropas suficientes
    if (atacante->tropas < 2) {
        return 0;
    }
    
    return 1;
}

// Função para simular um ataque entre territórios
void atacar(Territorio* atacante, Territorio* defensor) {
    printf("\n=== SIMULACAO DE ATAQUE ===\n");
    printf("%s (%s) atacando %s (%s)\n", 
           atacante->nome, atacante->cor, 
           defensor->nome, defensor->cor);
    
    // Simula a rolagem de dados (1-6) para cada lado
    int dadoAtacante = (rand() % 6) + 1;
    int dadoDefensor = (rand() % 6) + 1;
    
    printf("Dado do atacante: %d\n", dadoAtacante);
    printf("Dado do defensor: %d\n", dadoDefensor);
    
    if (dadoAtacante > dadoDefensor) {
        // Atacante vence
        printf("O atacante venceu a batalha!\n");
        
        // O defensor perde metade das tropas (arredondando para cima)
        int tropasPerdidas = (defensor->tropas + 1) / 2;
        defensor->tropas -= tropasPerdidas;
        
        // O atacante perde 1 tropa
        atacante->tropas -= 1;
        
        // Se o defensor ficou sem tropas, muda de dono
        if (defensor->tropas <= 0) {
            defensor->tropas = 1; // Mínimo de 1 tropa
            strcpy(defensor->cor, atacante->cor);
            printf("O territorio %s agora pertence ao exercito %s!\n", 
                   defensor->nome, defensor->cor);
        }
    } else {
        // Defensor vence ou empate (defensor ganha em caso de empate)
        printf("O defensor venceu a batalha!\n");
        
        // O atacante perde 1 tropa
        atacante->tropas -= 1;
    }
    
    // Exibe o resultado após a batalha
    printf("\n=== RESULTADO POS-BATALHA ===\n");
    printf("Atacante (%s): %d tropas\n", atacante->nome, atacante->tropas);
    printf("Defensor (%s): %d tropas\n", defensor->nome, defensor->tropas);
}

// Função para liberar a memória alocada
void liberarMemoria(Territorio* mapa) {
    free(mapa);
    printf("Memoria liberada com sucesso!\n");
}
